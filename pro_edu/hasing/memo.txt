Hasing <- DAT의 확장판
    key, value

사용하는 상황 : index로 사용하기 힘든 경우
    1. 문자열
    2. 매우 큰 정수 or 음수
    3. data를 묶어서 사용(객체) <- 메모리 부족

containsKey -> 반복 횟수 1회
containsValue -> 반복 횟수 data 수만큼 반복*******

HashMap의 데이터를 확인 하는 방법
    for (Map.Entry<String, Integer> entry : hm.entrySet()) {
        entry.getKey();
        entry.getValue();
    } // 데이터를 순서대로 가져오지는 않음, 실제로는 이렇게 사용하지는 않음

문자열을 base로 데이터를 관리하는 방법
    문자열 -> id 값
    민수 -> index 0 -> DAT[0] -> 관리할 정보
    민수 -> DAT[0] -> 관리할 정보
    HashMap<String, 관리Class> 
        HashMap<String, Integer> nameIdx = new HashMap<>();
        int getIdx(String name) {
            if (!nameIdx.containsKey(name)) {
                nameIdx.put(name, nameIdx.size());
            }
            return nameIdx.get(name);
        }

========================================================================================
DAT[index] = value
index : 어떤 의미
해당 의미에 대한 value 

=> DAT가 hasing 보다는 빠르다.

좌표 : x, y
    -> DAT[x][y] = value 
회사 Code, 사번 -> 이름
    -> DAT[회사 Code][사번] -> 이름


========================================================================================

Hash가 어떻게 동작하는가?
=> 시간과 직결
Index -> HashValue or HashCode

Hash에서 시간에 영향을 줄 수 있는 요인
1. HashCode 계산
    -> 계산을 최대한 간결하게!!
2. 같은 HashCode 일 때, 충돌이 얼마나 발생하는가 ?
    -> HashCode를 사용할 때, 같은 HashCode가 발생하지 않도록 하자

여러 값을 묶어서 key로 사용?
    1. HashCode를 계산하는 함수
    2. equals 함수 필요 

고유한 Key 값을 만들어서 사용하는 것도 좋음
    int getKey() {
        return a * 100 + b; // a, b의 크기를 잘 고려해야 한다.
    }

