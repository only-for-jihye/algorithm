세그먼트트리

효율이 좋은 상황
    1. S ~ E 까지 인덱스가 있을 때, 이 구간에 대한 처리를 해야할 때
    2. 연속된 구간에서 빠르게 정보를 알아내고 싶을 때
    update  <- logN
    query   <- logN 

- 원천 배열이 N개라면, 트리의 수는 N-1개
- 높이 차이에 따라 트리 구조가 완전하지 않다면... 원천 데이터의 4배로 트리를 만들면, 메모리를 확보하고 사용할 수 있다.

===============================================================================    
힌트~
- easy : 대놓고 segment tree 구나
- hard : 개수 관리
        -> 시간, 특정 기준 (대놓고 구간 X)
        -> 전체 구간에서 특정 우선순위에 대한 data를 여러번에 걸쳐 빠르게 찾아야하는 경우
구간 : 구간 크기가 결정되지 않았을 때 많이 사용, 구간 크기 1000~100만 사이 ... 1000만 잘 넘어가지 않음
===============================================================================    

import java.io.*;
import java.util.*;

class Main {

	static int originalData[] = {1,3,5,6,7,2,8,9};
	static int tree[] = new int[8*4]; // dataSize의 4배
	
	static int merge(int left, int right) {
		return left + right;
	}
	
	static void build(int node, int st, int en) { // 첫 그래프 구성
		// 끝조건(기저조건)
		if(st == en) {
			tree[node] = originalData[st];
			return;
		}
		
		int mid = (st+en)/2;
		build(node * 2,  	st, 	mid); // 왼쪽 자식을 계산
		build(node * 2+1, 	mid+1,	en ); // 오른쪽 자식을 계산
		
		tree[node] = merge(tree[node*2], tree[node*2 + 1]);
	}
	
	// S~E까지의 계산 결과
	static int query(int node, int st, int en,  int S, int E) {
		// 지금 node가 갖고있는 정보는 내가 원하는 DATA만?
		// 불순물이 끼어 있는가?
		if(S <= st && en <= E) // 정확하게 내가 원하는 DATA만 포함함
			return tree[node];
		if(en < S || E < st) // 불순물만?
			return 0; // 계산에 영향을 주지 않는 값 <<----- 구간처리에 따라 바뀌는 값
		
		// 적당히 섞여 있다.
		int mid = (st + en) / 2;
		int left 	= query(node*2,		st,		mid,	S, E);
		int right 	= query(node*2+1,	mid+1,	en,		S, E);
		return merge(left, right);
	}
	
	// data를 하나 수정
	static void update(int node, int st, int en,  int idx, int diff) {
		// 필요 없는 data구간이면 버리고
		if(en < idx || idx < st) return;
		if(st == idx && idx == en) { // 정확히 idx data만 갖고있는 node면
			tree[node] = diff;  // data를 변경
			return;
		}
			
		// idx가 포함된 구간이다.
		int mid = (st + en) / 2;
		update(node * 2,		st,		mid,	idx, diff);//왼쪽
		update(node * 2 + 1,	mid+1,	en,		idx, diff);//오른쪽
		tree[node] = merge(tree[node*2], tree[node*2+1]);
	}
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		build(1, 0, 7);

		System.out.println(query(1, 0, 7, 2, 6));
		update(1,0,7, 4, 12);

		System.out.println(query(1, 0, 7, 2, 6));
	}
}